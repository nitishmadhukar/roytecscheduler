<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Sch-data-TimeAxis'>/**
</span>@class Sch.data.TimeAxis
@extends Ext.data.JsonStore

A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
This is a pure &quot;data&quot; (model) representation of the time axis and has no UI elements.

The time axis can be {@link #continuous} or not. In continuous mode, each timespan starts where the previous ended, and in non-continuous mode
 there can be gaps between the ticks.
A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.

To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
To do that, subclass this class and override the {@link #generateTicks} method. See the `noncontinuous-timeaxis` example in the Ext Scheduler SDK for guidance.

The other alternative is to call the {@link #filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
Calling the {@link #clearFilter} method will return you to full time axis.

*/
Ext.define(&quot;Sch.data.TimeAxis&quot;, {
    extend      : &quot;Ext.data.JsonStore&quot;,

    requires    : [
        'Sch.util.Date',
        // this &quot;require&quot; is needed for Sencha Touch
        'Sch.model.TimeAxisTick'
    ],

<span id='Sch-data-TimeAxis-property-model'>    model               : 'Sch.model.TimeAxisTick',
</span>
<span id='Sch-data-TimeAxis-cfg-continuous'>    /**
</span>    * @cfg {Boolean} continuous
    * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
    */
    continuous          : true,

<span id='Sch-data-TimeAxis-property-originalContinuous'>    originalContinuous  : null,
</span>
<span id='Sch-data-TimeAxis-cfg-autoAdjust'>    /**
</span>    * @cfg {Boolean} autoAdjust
    * Automatically adjust the timespan when generating ticks with {@link #generateTicks} according to the `viewPreset` configuration. Setting this to false
    * may lead to shifting time/date of ticks.
    */
    autoAdjust          : true,

<span id='Sch-data-TimeAxis-property-unit'>    unit                : null,
</span><span id='Sch-data-TimeAxis-property-increment'>    increment           : null,
</span><span id='Sch-data-TimeAxis-property-resolutionUnit'>    resolutionUnit      : null,
</span><span id='Sch-data-TimeAxis-property-resolutionIncrement'>    resolutionIncrement : null,
</span>
<span id='Sch-data-TimeAxis-property-weekStartDay'>    weekStartDay        : null,
</span>
<span id='Sch-data-TimeAxis-property-mainUnit'>    mainUnit            : null,
</span><span id='Sch-data-TimeAxis-property-shiftUnit'>    shiftUnit           : null,
</span>
<span id='Sch-data-TimeAxis-property-shiftIncrement'>    shiftIncrement      : 1,
</span><span id='Sch-data-TimeAxis-property-defaultSpan'>    defaultSpan         : 1,
</span>
<span id='Sch-data-TimeAxis-property-isConfigured'>    isConfigured        : false,
</span>
<span id='Sch-data-TimeAxis-property-adjustedStart'>    // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick
</span>    // these dates will contain adjusted start/end (like if the tick has not been truncated)
    adjustedStart       : null,
<span id='Sch-data-TimeAxis-property-adjustedEnd'>    adjustedEnd         : null,
</span><span id='Sch-data-TimeAxis-property-visibleTickStart'>    // the visible position in the first tick, can actually be &gt; 1 because the adjustment is done by the `mainUnit`
</span>    visibleTickStart    : null,
<span id='Sch-data-TimeAxis-property-visibleTickEnd'>    // the visible position in the first tick, is always ticks count - 1 &lt; value &lt;= ticks count, in case of autoAdjust, always = ticks count
</span>    visibleTickEnd      : null,

<span id='Sch-data-TimeAxis-property-presetName'>    // name of the current preset
</span>    presetName          : null,

<span id='Sch-data-TimeAxis-cfg-mode'>    /**
</span>     * @cfg {String} mode This option determines how timeaxis should be rounded.
     * When we round timeAxis for calendar we want to get minimum number of weeks that comprises desired month.
     * Options: ['plain', 'calendar']
     */
    mode                : 'plain',

<span id='Sch-data-TimeAxis-cfg-startTime'>    /**
</span>     * @cfg {Number} startTime Start time for calendar mode, used only with day/week presets.
     */
    startTime           : 0,
    
<span id='Sch-data-TimeAxis-cfg-endTime'>    /**
</span>     * @cfg {Number} endTime End time for calendar mode, used only with day/week presets.
     */
    endTime             : 24,

<span id='Sch-data-TimeAxis-event-beforereconfigure'>    /**
</span>     * @event beforereconfigure
     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     * @param {Date} startDate The new time axis start date
     * @param {Date} endDate The new time axis end date
     */

<span id='Sch-data-TimeAxis-event-endreconfigure'>    /**
</span>     * @event endreconfigure
     * @private
     * Event that is triggered when we end reconfiguring and everything ui-related should be done
     */

<span id='Sch-data-TimeAxis-event-reconfigure'>    /**
</span>     * @event reconfigure
     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     */

<span id='Sch-data-TimeAxis-method-constructor'>    // private
</span>    constructor : function(config) {
        var me = this;

        config = config || {};

        // For Sencha Touch, config system
        if (me.setModel) {
            me.setModel(me.model);
        }

        me.setMode(config.mode || me.mode);

        me.originalContinuous = me.continuous;

        me.callParent(arguments);

        me.on(Ext.versions.touch ? 'refresh' : 'datachanged', function(ta) {
            me.fireEvent('reconfigure', me, false);
        });

        me.on('endreconfigure', function(me, suppressRefresh) {
            me.fireEvent('reconfigure', me, suppressRefresh);
        });

        if (config.viewPreset) {
            var preset      = Sch.preset.Manager.getPreset(config.viewPreset);
            preset &amp;&amp; me.consumeViewPreset(preset);
        }

        // not sure what me.start is but just in case I'm leaving previous condition
        if (config.start || me.start) {
            me.reconfigure(config);
        }
    },

<span id='Sch-data-TimeAxis-method-reconfigure'>    /**
</span>    * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
    * @param {Object} config
    * @private
    */
    reconfigure : function (config, suppressRefresh) {
        this.isConfigured   = true;

        Ext.apply(this, config);

        var adjusted        = this.getAdjustedDates(config.start, config.end, true);
        var normalized      = this.getAdjustedDates(config.start, config.end);

        var start           = normalized.start;
        var end             = normalized.end;

        if (this.fireEvent('beforereconfigure', this, start, end) !== false) {

            this.fireEvent('beginreconfigure', this);

            var unit                = this.unit;
            var increment           = this.increment || 1;
            var ticks               = this.generateTicks(start, end, unit, increment, this.mainUnit);

            // Suspending to be able to detect an invalid filter
            this.removeAll(true);
            this.suspendEvents();
            this.add(ticks);

            if (this.getCount() === 0) {
                Ext.Error.raise('Invalid time axis configuration or filter, please check your input data.');
            }
            this.resumeEvents();

            var DATE                = Sch.util.Date;
            var count               = ticks.length;

            if (this.isContinuous()) {
                this.adjustedStart      = adjusted.start;
                this.adjustedEnd        = this.getNext(count &gt; 1 ? ticks[ count - 1 ].start : adjusted.start, unit, increment);
            } else {
                this.adjustedStart      = this.getStart();
                this.adjustedEnd        = this.getEnd();
            }

            // if visibleTickStart &gt; 1 this means some tick is fully outside of the view - we are not interested in it and want to
            // drop it and adjust &quot;adjustedStart&quot; accordingly
            do {
                // TODO this has to use more sophisticated formula to take into account that months for example can be expressed in ms consistenly
                this.visibleTickStart   = (this.getStart() - this.adjustedStart) / (DATE.getUnitDurationInMs(unit) * increment);

                if (this.visibleTickStart &gt;= 1) this.adjustedStart = DATE.getNext(this.adjustedStart, unit, increment);
            } while (this.visibleTickStart &gt;= 1);

            do {
                this.visibleTickEnd     = count - (this.adjustedEnd - this.getEnd()) / (DATE.getUnitDurationInMs(unit) * increment);

                if (count - this.visibleTickEnd &gt;= 1) this.adjustedEnd = DATE.getNext(this.adjustedEnd, unit, -1);
            } while (count - this.visibleTickEnd &gt;= 1);

            this.fireEvent('endreconfigure', this, suppressRefresh);
        }
    },

<span id='Sch-data-TimeAxis-method-setMode'>    setMode : function (mode) {
</span>        this.mode = mode;
        
        if (mode === 'calendar') {
            this.generateTicksValidatorFn = function (start) { 
                if (this.startTime &gt; 0 || this.endTime &lt; 24) {
                    return (start.getHours() &gt;= this.startTime &amp;&amp; start.getHours() &lt; this.endTime);
                } else {
                    return true;
                }
            };
        } else {
            this.generateTicksValidatorFn = function () { return true; };
        }
    },

<span id='Sch-data-TimeAxis-method-setTimeSpan'>    /**
</span>    * Changes the time axis timespan to the supplied start and end dates.
    * @param {Date} start The new start date
    * @param {Date} end The new end date
    */
    setTimeSpan : function (start, end) {
        var adjusted    = this.getAdjustedDates(start, end);

        start           = adjusted.start;
        end             = adjusted.end;

        if (this.getStart() - start !== 0 || this.getEnd() - end !== 0) {
            this.reconfigure({
                start   : start,
                end     : end
            });
        }
    },

<span id='Sch-data-TimeAxis-method-filterBy'>    /**
</span>     * [Experimental] Filter the time axis by a function. The passed function will be called with each tick in time axis.
     * If the function returns true, the 'tick' is included otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive an object with start/end properties, and 'index' of the tick.
     * @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
     */
    filterBy : function(fn, scope) {
        this.continuous = false;
        scope = scope || this;

        this.clearFilter(true);
        // Suspending to be able to detect an invalid filter
        this.suspendEvents(true);
        this.filter([{
            filterFn : function(t, index) {
                return fn.call(scope, t.data, index);
            }
        }]);

        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise('Invalid time axis filter - no ticks passed through the filter. Please check your filter method.');
        }
        this.resumeEvents();
    },

<span id='Sch-data-TimeAxis-method-isContinuous'>    /**
</span>     * Returns `true` if the time axis is continuos (will return `false` when filtered)
     * @return {Boolean}
     */
    isContinuous : function() {
        return this.continuous &amp;&amp; !this.isFiltered();
    },

<span id='Sch-data-TimeAxis-method-clearFilter'>    /**
</span>     * Clear the current filter of the time axis
     */
    clearFilter : function() {
        this.continuous = this.originalContinuous;
        this.callParent(arguments);
    },

<span id='Sch-data-TimeAxis-method-generateTicks'>    /**
</span>     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
        {
            start       : ..., // start date
            end         : ...  // end date
        }
     *
     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
     *
     * @param {Date} startDate The start date of the interval
     * @param {Date} endDate The end date of the interval
     * @param {String} unit The unit of the time axis
     * @param {Mixed} increment The increment for the unit specified.
     * @return {Array} ticks The ticks representing the time axis
     */
    generateTicks : function (start, end, unit, increment) {
        var ticks           = [],
            intervalEnd,
            DATE            = Sch.util.Date,
            dstDiff         = 0;

        unit                = unit || this.unit;
        increment           = increment || this.increment;

        var adjusted        = this.getAdjustedDates(start, end);

        start               = adjusted.start;
        end                 = adjusted.end;

        while (start &lt; end) {
            intervalEnd     = this.getNext(start, unit, increment);

            if (!this.autoAdjust &amp;&amp; intervalEnd &gt; end) intervalEnd = end;

            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
            // Only do this for HOUR resolution currently, and only handle it once per tick generation.
            if (unit === DATE.HOUR &amp;&amp; increment &gt; 1 &amp;&amp; ticks.length &gt; 0 &amp;&amp; dstDiff === 0) {
                var prev    = ticks[ ticks.length - 1 ];

                dstDiff     = ((prev.start.getHours() + increment) % 24) - prev.end.getHours();

                if (dstDiff !== 0) {
                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis &quot;symmetric&quot;.
                    intervalEnd = DATE.add(intervalEnd, DATE.HOUR, dstDiff);
                }
            }

            this.generateTicksValidatorFn(start) &amp;&amp; ticks.push({
                start   : start,
                end     : intervalEnd
            });
            
            start           = intervalEnd;
        }

        return ticks;
    },


<span id='Sch-data-TimeAxis-method-getVisibleTickTimeSpan'>    getVisibleTickTimeSpan : function () {
</span>        return this.isContinuous() ? this.visibleTickEnd - this.visibleTickStart : this.getCount();
    },


<span id='Sch-data-TimeAxis-method-getAdjustedDates'>    getAdjustedDates : function (start, end, forceAdjust) {
</span>        var DATE    = Sch.util.Date;
        start       = start || this.getStart();
        end         = end || DATE.add(start, this.mainUnit, this.defaultSpan);

        if (this.mode === 'calendar') {
            // 'month' is tricky so we have to handle it separately
            if (this.shiftUnit === DATE.MONTH) {
                var startWeekEnd = DATE.add(start, DATE.WEEK, 1);
                var endWeekStart = DATE.add(end, DATE.WEEK, -1);
                // when this method is called from 'switchViewPreset' end date isn't provided, so we should just create one
                if (!end) {
                    end = this.getNext(start, this.shiftUnit, 1);
                    end = this.ceilDate(end, false, this.shiftUnit, 1);
                    end = this.ceilDate(end, false, this.mainUnit, 1);
                }
                if (startWeekEnd.getMonth() !== start.getMonth() &amp;&amp; endWeekStart.getMonth() !== end.getMonth()) {
                    return {
                        start   : start,
                        end     : end
                    };
                }
            }

            // This code sets time span to 1 viewPreset's shiftUnit from the time axis start date
            var adjustedStart   = this.floorDate(start, false, this.shiftUnit, 1);
            adjustedStart       = this.floorDate(adjustedStart, false, this.mainUnit, 1);

            var clone           = this.getNext(start, this.shiftUnit, 1);
            var adjustedEnd     = this.ceilDate(clone, false, this.shiftUnit, 1);
            adjustedEnd         = this.ceilDate(adjustedEnd, false, this.mainUnit, 1);

            return {
                start   : adjustedStart,
                end     : adjustedEnd
            };
        } else {
            return this.autoAdjust || forceAdjust ? {
                start   : this.floorDate(start, false, this.autoAdjust ? this.mainUnit : this.unit, 1),
                end     : this.ceilDate(end, false, this.autoAdjust ? this.mainUnit : this.unit, 1)
            } : {
                start   : start,
                end     : end
            };
        }
    },

<span id='Sch-data-TimeAxis-method-getTickFromDate'>    /**
</span>     * Gets a tick &quot;coordinate&quot; representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
     * @param {Date} date the date
     * @return {Number} the tick position on the scale or -1 if the date is not part of the time axis
     */
    getTickFromDate : function (date) {
        var ticks           = this.data.items;
        var lastTickIndex   = ticks.length - 1;

        // quick bailout
        if (date &lt; ticks[ 0 ].data.start || date &gt; ticks[ lastTickIndex ].data.end) {
            return -1;
        }

        var tick, tickStart, tickEnd;

        if (this.isContinuous()) {
            if (date - ticks[ 0 ].data.start === 0) return this.visibleTickStart;
            if (date - ticks[ lastTickIndex ].data.end === 0) return this.visibleTickEnd;

            var adjustedStart   = this.adjustedStart;
            var adjustedEnd     = this.adjustedEnd;

            var tickIndex       = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));

            // for the date == adjustedEnd case
            if (tickIndex &gt; lastTickIndex) tickIndex = lastTickIndex;

            tickStart           = tickIndex === 0 ? adjustedStart : ticks[ tickIndex ].data.start;
            tickEnd             = tickIndex == lastTickIndex ? adjustedEnd : ticks[ tickIndex ].data.end;

            tick                = tickIndex + (date - tickStart) / (tickEnd - tickStart);

            // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but
            // from `visibleTickStart` coordinate, this check generally repeats the &quot;quick bailout&quot; check in the begining of the method,
            // but still
            if (tick &lt; this.visibleTickStart || tick &gt; this.visibleTickEnd) return -1;

            return tick;
        } else {
            for (var i = 0; i &lt;= lastTickIndex; i++) {
                tickEnd         = ticks[ i ].data.end;

                if (date &lt;= tickEnd) {
                    tickStart   = ticks[ i ].data.start;

                    // date &lt; tickStart can occur in filtered case
                    tick        = i + (date &gt; tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);

                    return tick;
                }
            }
        }

        return -1;
    },

<span id='Sch-data-TimeAxis-method-getDateFromTick'>    /**
</span>    * Gets the time represented by a tick &quot;coordinate&quot;.
    * @param {Number} tick the tick &quot;coordinate&quot;
    * @param {String} roundingMethod The rounding method to use
    * @return {Date} The date to represented by the tick &quot;coordinate&quot;, or null if invalid.
    */
    getDateFromTick : function (tick, roundingMethod) {
        if (tick === this.visibleTickEnd) return this.getEnd();

        var wholeTick   = Math.floor(tick),
            fraction    = tick - wholeTick,
            t           = this.getAt(wholeTick);

        if (!t) return null;

        var tickData    = t.data;
        var start       = wholeTick === 0 ? this.adjustedStart : tickData.start;
        // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end
        var end         = (wholeTick == this.getCount() - 1) &amp;&amp; this.isContinuous() ? this.adjustedEnd : tickData.end;

        var date        = Sch.util.Date.add(start, Sch.util.Date.MILLI, fraction * (end - start));

        if (roundingMethod) {
            date        = this[ roundingMethod + 'Date' ](date);
        }

        return date;
    },

<span id='Sch-data-TimeAxis-method-getTicks'>    /**
</span>    * Returns the ticks of the timeaxis in an array of objects with a &quot;start&quot; and &quot;end&quot; date.
    * @return {Object[]} the ticks on the scale
    */
    getTicks : function() {
        var ticks = [];

        this.each(function (r) { ticks.push(r.data); });
        return ticks;
    },

<span id='Sch-data-TimeAxis-method-getStart'>    /**
</span>    * Method to get the current start date of the time axis
    * @return {Date} The start date
    */
    getStart : function() {
        var first = this.first();

        if (first) {
            return new Date(first.data.start);
        }
        return null;
    },

<span id='Sch-data-TimeAxis-method-getEnd'>    /**
</span>    * Method to get a the current end date of the time axis
    * @return {Date} The end date
    */
    getEnd : function() {
        var last = this.last();

        if (last) {
            return new Date(last.data.end);
        }
        return null;
    },

<span id='Sch-data-TimeAxis-method-floorDate'>    // Floors a date and optionally snaps it to one of the following resolutions:
</span>    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,
    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
    //
    // returns a copy of the original date
    // private
    floorDate : function(date, relativeToStart, resolutionUnit, incr) {
        relativeToStart = relativeToStart !== false;

        var dt          = Ext.Date.clone(date),
            relativeTo  = relativeToStart ? this.getStart() : null,
            increment   = incr || this.resolutionIncrement,
            unit;

        if (resolutionUnit) {
            unit        = resolutionUnit;
        } else {
            unit        = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        var DATE        = Sch.util.Date;
        var snap        = function (value, increment) { return Math.floor(value / increment) * increment; };

        switch (unit) {
            case DATE.MILLI:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInMilliseconds(relativeTo, dt), increment));
                }
                break;

            case DATE.SECOND:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInSeconds(relativeTo, dt), increment) * 1000);
                } else {
                    dt.setMilliseconds(0);
                    dt.setSeconds(snap(dt.getSeconds(), increment));
                }
                break;

            case DATE.MINUTE:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.SECOND, snap(DATE.getDurationInMinutes(relativeTo, dt), increment) * 60);
                } else {
                    dt.setMinutes(snap(dt.getMinutes(), increment));
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                }
                break;

            case DATE.HOUR:
                if (relativeToStart) {
                    dt           = DATE.add(relativeTo, DATE.MINUTE, snap(DATE.getDurationInHours(this.getStart(), dt), increment) * 60);
                } else {
                    dt.setMinutes(0);
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                    dt.setHours(snap(dt.getHours(), increment));
                }
                break;

            case DATE.DAY:
                if (relativeToStart) {
                    dt            = DATE.add(relativeTo, DATE.DAY, snap(DATE.getDurationInDays(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    // days are 1-based so need to make additional adjustments
                    dt.setDate(snap(dt.getDate() - 1, increment) + 1);
                }
                break;

            case DATE.WEEK:
                var day      = dt.getDay()       || 7;
                var startDay = this.weekStartDay || 7;
                Sch.util.Date.clearTime(dt);

                dt      = DATE.add(dt, DATE.DAY, day &gt;= startDay ? startDay - day : -(7 - startDay + day));

                // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)
                if (dt.getDay() !== startDay &amp;&amp; dt.getHours() === 23) {
                    dt = DATE.add(dt, DATE.HOUR, 1);
                }
                break;

            case DATE.MONTH:
                if (relativeToStart) {
                    dt      = DATE.add(relativeTo, DATE.MONTH, snap(DATE.getDurationInMonths(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    dt.setDate(1);
                    dt.setMonth(snap(dt.getMonth(), increment));
                }
                break;

            case DATE.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt                      = DATE.add(dt, DATE.MONTH, - (dt.getMonth() % 3));
                break;

            case DATE.YEAR:
                if (relativeToStart) {
                    dt                  = DATE.add(relativeTo, DATE.YEAR, snap(DATE.getDurationInYears(relativeTo, dt), increment));
                } else {
                    // years are 1-based so need to make additional adjustments
                    dt                  = new Date(snap(date.getFullYear() - 1, increment) + 1, 0, 1);
                }
                break;
        }

        return dt;
    },


<span id='Sch-data-TimeAxis-method-roundDate'>    // Rounds the date to nearest unit increment
</span>    // private
    roundDate : function(date, relativeTo) {
        var dt = Ext.Date.clone(date),
            increment = this.resolutionIncrement;

        relativeTo = relativeTo || this.getStart();

        switch(this.resolutionUnit) {
            case Sch.util.Date.MILLI:
                var milliseconds = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt),
                    snappedMilliseconds = Math.round(milliseconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedMilliseconds);
                break;

            case Sch.util.Date.SECOND:
                var seconds = Sch.util.Date.getDurationInSeconds(relativeTo, dt),
                    snappedSeconds = Math.round(seconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedSeconds * 1000);
                break;

            case Sch.util.Date.MINUTE:
                var minutes = Sch.util.Date.getDurationInMinutes(relativeTo, dt),
                    snappedMinutes = Math.round(minutes / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, snappedMinutes * 60);
                break;

            case Sch.util.Date.HOUR:
                var nbrHours = Sch.util.Date.getDurationInHours(relativeTo, dt),
                    snappedHours = Math.round(nbrHours / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, snappedHours * 60);
                break;

            case Sch.util.Date.DAY:
                var nbrDays = Sch.util.Date.getDurationInDays(relativeTo, dt),
                    snappedDays = Math.round(nbrDays / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);
                break;

            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);

                var distanceToWeekStartDay = dt.getDay() - this.weekStartDay,
                    toAdd;

                if (distanceToWeekStartDay &lt; 0) {
                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;
                }

                if (Math.round(distanceToWeekStartDay/7) === 1) {
                    toAdd = 7 - distanceToWeekStartDay;
                } else {
                    toAdd = -distanceToWeekStartDay;
                }

                dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, toAdd);
                break;

            case Sch.util.Date.MONTH:
                var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt) + (dt.getDate() / Ext.Date.getDaysInMonth(dt)),
                    snappedMonths = Math.round(nbrMonths / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
                break;

            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, 3 - (dt.getMonth() % 3));
                break;

            case Sch.util.Date.YEAR:
                var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt),
                    snappedYears = Math.round(nbrYears / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
                break;
        }

        return dt;
    },

<span id='Sch-data-TimeAxis-method-ceilDate'>    // private
</span>    ceilDate : function(date, relativeToStart, resolutionUnit) {
        var dt = Ext.Date.clone(date);
        relativeToStart = relativeToStart !== false;

        var increment = relativeToStart ? this.resolutionIncrement : 1,
            doCall = false,
            unit;

        if (resolutionUnit){
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        switch (unit) {
            case Sch.util.Date.HOUR:
                if (dt.getMinutes() &gt; 0 || dt.getSeconds() &gt; 0 || dt.getMilliseconds() &gt; 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.DAY:
                if (dt.getHours() &gt; 0 || dt.getMinutes() &gt; 0 || dt.getSeconds() &gt; 0 || dt.getMilliseconds() &gt; 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);
                if (dt.getDay() !== this.weekStartDay || date.getTime() - dt.getTime() &gt; 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.MONTH:
                Sch.util.Date.clearTime(dt);
                if (dt.getDate() !== 1 || date.getTime() - dt.getTime() &gt; 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() &gt; 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.YEAR:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() &gt; 0) {
                    doCall = true;
                }
            break;

            default:
            break;
        }

        if (doCall) {
            return this.getNext(dt, unit, increment);
        } else {
            return dt;
        }
    },

<span id='Sch-data-TimeAxis-method-getNext'>    // private
</span>    getNext : function(date, unit, increment) {
        return Sch.util.Date.getNext(date, unit, increment, this.weekStartDay);
    },

<span id='Sch-data-TimeAxis-method-getResolution'>    // private
</span>    getResolution : function() {
        return {
            unit : this.resolutionUnit,
            increment : this.resolutionIncrement
        };
    },

<span id='Sch-data-TimeAxis-method-setResolution'>    // private
</span>    setResolution : function(unit, increment) {
        this.resolutionUnit = unit;
        this.resolutionIncrement = increment || 1;
    },

<span id='Sch-data-TimeAxis-method-shift'>    /**
</span>     * Moves the time axis by the passed amount and unit.
     * @param {Number} amount The number of units to jump
     * @param {String} unit The unit (Day, Week etc)
     */
    shift: function (amount, unit) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

<span id='Sch-data-TimeAxis-method-shiftNext'>    /**
</span>    * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
    * config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function (amount) {
        amount      = amount || this.getShiftIncrement();
        var unit    = this.getShiftUnit();

        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

<span id='Sch-data-TimeAxis-method-shiftPrevious'>    /**
</span>    * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function (amount) {
        amount = -(amount || this.getShiftIncrement());
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

<span id='Sch-data-TimeAxis-method-getShiftUnit'>    getShiftUnit: function () {
</span>        return this.shiftUnit || this.mainUnit;
    },

<span id='Sch-data-TimeAxis-method-getShiftIncrement'>    // private
</span>    getShiftIncrement: function () {
        return this.shiftIncrement || 1;
    },

<span id='Sch-data-TimeAxis-method-getUnit'>    // private
</span>    getUnit: function () {
        return this.unit;
    },

<span id='Sch-data-TimeAxis-method-getIncrement'>    // private
</span>    getIncrement: function () {
        return this.increment;
    },
    
<span id='Sch-data-TimeAxis-method-getRowTicks'>    // to keep rows and time axis in sync, we use this function to return ticks to generate rows.
</span>    getRowTicks    : function () {
        if (this.mode === 'plain') {
            return;
        } else {
            var start = this.getStart();
            var end = Sch.util.Date.add(start, this.headerConfig.middle.splitUnit, 1);
            
            var endIndex = this.findBy(function (record) {
                return record.getStartDate().getTime() &gt;= end.getTime();
            });
            
            // if no such record was found - we are dealing with day view
            if (endIndex === -1) {
                return this.getRange();
            }
            
            return this.getRange(0, endIndex - 1);
        }
    },

<span id='Sch-data-TimeAxis-method-dateInAxis'>    /**
</span>    * Returns true if the passed date is inside the span of the current time axis.
    * @param {Date} date The date to query for
    * @return {Boolean} true if the date is part of the timeaxis
    */
    dateInAxis: function(date) {
        return Sch.util.Date.betweenLesser(date, this.getStart(), this.getEnd());
    },

<span id='Sch-data-TimeAxis-method-timeSpanInAxis'>    /**
</span>    * Returns true if the passed timespan is part of the current time axis (in whole or partially).
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @return {boolean} true if the timespan is part of the timeaxis
    */
    timeSpanInAxis: function(start, end) {
        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(start, end, this.getStart(), this.getEnd());
        } else {
            return (start &lt; this.getStart() &amp;&amp; end &gt; this.getEnd()) ||
                   this.getTickFromDate(start) !== this.getTickFromDate(end);
        }
    },

<span id='Sch-data-TimeAxis-method-isRangeInAxis'>    // Accepts a Sch.model.Range model
</span>    isRangeInAxis: function(range) {
        var start = range.getStartDate(),
            end = range.getEndDate();

        // only consider fully scheduled ranges
        if (!start || !end) return false;

        return this.timeSpanInAxis(start, end);
    },


<span id='Sch-data-TimeAxis-method-forEachAuxInterval'>    /**
</span>     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * @protected
     * @param {String} unit The unit to use when iterating over the timespan
     * @param {Number} increment The increment to use when iterating over the timespan
     * @param {Function} iteratorFn The function to call
     * @param {Object} scope (optional) The &quot;this&quot; object to use for the function call
     */
    forEachAuxInterval : function (unit, increment, iteratorFn, scope) {
        scope               = scope || this;

        var end             = this.getEnd(),
            dt              = this.getStart(),
            i               = 0,
            intervalEnd;

        if (dt &gt; end) throw 'Invalid time axis configuration';

        while (dt &lt; end) {
            intervalEnd     =  Sch.util.Date.min(this.getNext(dt, unit, increment || 1), end);
            iteratorFn.call(scope, dt, intervalEnd, i);
            dt              = intervalEnd;
            i++;
        }
    },


<span id='Sch-data-TimeAxis-method-consumeViewPreset'>    consumeViewPreset : function (preset) {
</span>        Ext.apply(this, {
            unit                : preset.getBottomHeader().unit,
            increment           : preset.getBottomHeader().increment || 1,

            resolutionUnit      : preset.timeResolution.unit,
            resolutionIncrement : preset.timeResolution.increment,

            mainUnit            : preset.getMainHeader().unit,
            shiftUnit           : preset.shiftUnit,
            shiftIncrement      : preset.shiftIncrement || 1,

            defaultSpan         : preset.defaultSpan || 1,
            presetName          : preset.name,

            // Calendar columns are updated upon 'datachanged' event on this object.
            // We have to pass headerConfig in order to render them correctly (timeAxisViewModel is incorrect in required time)
            headerConfig        : preset.headerConfig
        });
    }
});</pre>
</body>
</html>
